/*
Алгоритм: тут простая рекурсия, в самой функции всегда меняем нулевой элемент и 
последний (общее количество - 1, т.к. первый индекс массива нуль, а не единица),
далее если количество оставшихся элементов больше 2 (т.е. еще есть что менять местами),
запускакм эту же функцию, но сдвигаем на 1 элемент вправо, и на 1 влево 
(т.е. уменьшаем общее количество на 2).

Наглядный пример:
1 запуск функции - {3, 4, 1, 7, 5, 6, 11, 9, 8}, 9 - (последовательность из 9 элементов)
2 запуск         -    {4, 1, 7, 5, 6, 11, 9}   , 7    - (последовательность из 7 элементов)
3 запуск         -       {1, 7, 5, 6, 11}      , 5
4 запуск         -          {7, 5, 6}          , 3
5 запуск         -             {5}             - остался 1 элемент массива,
 значит рекурсия на этом заканчивается, т.к. нужно хотя бы 2 элемента
*/

#include <stdio.h>

void reverse(int m_pointer[], int m_count) {
    int buf = m_pointer[0];
    m_pointer[0] = m_pointer[m_count-1];
    m_pointer[m_count-1] = buf;
    
    if (m_count>2) reverse(&m_pointer[1], m_count-2);
}

int main() {
    int m[] = {3, 4, 1, 7, 4, 5, 6, 11, 9, 8};
    
    for(int a=0; a<sizeof(m)/sizeof(m[0]); a++) {
        printf("%d ", m[a]);
    }
    reverse(&m[0], sizeof(m)/sizeof(m[0]));
    printf("\n");
    for(int a=0; a<sizeof(m)/sizeof(m[0]); a++) {
        printf("%d ", m[a]);
    }
    
    return 0;
}
