### 10. Функуции

Функция, это часть кода, который можно выполнить в другой части.
У функции есть имя, принимаемые значения и опционально, возвращаемое значение (т.е. результут ее выполнения).

Функция имеет следующую структуру:
```c
тип_функции имя_функции(принимаемые значения){
  return возвращаемое значение;
}
```

Помимо стандартных [типов данных (пт. 2)](https://github.com/rejedai/c-help#2-%D0%BF%D0%B5%D1%80%D0%B5%D0%BC%D0%B5%D0%BD%D0%BD%D1%8B%D0%B5), функция может быть `void`, это обозначает что она не должна возвращать значения.
Пример:

Функция возвращающая значение:
```c
#include <stdio.h>

int func() {
    return 4;
}

int main() {
    int value = func();
    printf("%d", value);
    
    return 0;
}
```
Результат:
```
4
```


Если заменить `int` на `void`, получим ошибку, т.к. `void` не должен возвращать значений.
```c
#include <stdio.h>

void func() {
    return 4;
}

int main() {
    int value = func();
    printf("%d", value);
    
    return 0;
}
```
Результат:
```
/tmp/17IV9NJkqa.c:4:12: warning: 'return' with a value, in function returning void
```

Можно использовать функцию `void` для вывода суммы двух значений, которые в нее передадим, например 5 и 9:
```c
#include <stdio.h>

void func(int x, int y) { //получаемые значения запишутся в x и y
    printf("%d", x+y);
}

int main() {
    func(5, 9); //передаем в функцию значения
    
    return 0;
}
```
Результат:
```
14
```

### 11. Рекурсия
Рекурсия это вызов функции внутри себя. Это достаточно полезный прием, но нужно использовать с большой осторожностью, рекурсия может быть бесконечной, т.е. при использовании рекурсии нужно заранее продумать когда она завершится.

Пример простой рекурсии. Вывод значений от N до 0, N указывается при вызове функции:
```c
#include <stdio.h>

void recursion(int n) {
    printf("%d\n", n);
    if (n>0) recursion(n-1); //тут происходит вызов функции внутри себя, т.е. происходит рекурсия. Пока n больше нуля фунция будет запускать сама себя с уменьшением значения n на 1
}

int main() {
    recursion(10);
    
    return 0;
}
```

Результат:
```
10
9
8
7
6
5
4
3
2
1
0
```

### 12. Указатели

Указатель по сути это переменная, которая хранит адрес объекта. Для передачи адреса переменной используется символ амперсанд (`&`), для получения звезда (`*`). Разберу 2 простых примера.

Без указателя:
```c
#include <stdio.h>

void pointer_example(int n) {
    n = 5;
    printf("2. %d\n", n); // Смотрим значение внутри функции
}

int main() {
    int f;
    
    f = 10; // Кладем в переменную f 10
    printf("1. %d\n", f); // Смотрим ее значение до передачи в функцию
    pointer_example(f);
    printf("3. %d\n", f); // Смотрим ее значение после передачи в функцию

    return 0;
}
```

Результат:
```
1. 10
2. 5
3. 10
```


С указателем:
```c
#include <stdio.h>

void pointer_example(int *n) {
    *n = 5;
    printf("2. %d\n", *n); // Смотрим значение внутри функции
}

int main() {
    int f;
    
    f = 10; // Кладем в переменную f 10
    printf("1. %d\n", f); // Смотрим ее значение до передачи в функцию
    pointer_example(&f);
    printf("3. %d\n", f); // Смотрим ее значение после передачи в функцию

    return 0;
}
```

Результат:
```
1. 10
2. 5
3. 5
```

Что произошло:
*!!Адреса переменных условные, компьютер подбирает их сам*
В первом случае, мы создаем переменную `f` и компьютер выделяет под нее память, по адресу `00000001`, далее в 10 строчке, кладем `10` по этому адресу. Итого:
```
f - 00000001 - 10
``` 
имеем переменную `f`, которая хранится по адресу `00000001`, где храним 10.
Далее вызываем функцию и передаем в нее 10, для этого компьютер создает еще одну переменную n, по адресу `00000002`, куда кладет 10. Поэтому когда в функции меняем значение, значение меняется только по адресу `00000002`

Память после выполнения программы:
```
f - 00000001 - 10
n - 00000002 - 5
```

Во втором случае при вызове функции мы передаем не значение, т.е. `10`, а адрес переменной `f`, итого в фукции мы меняем значение по тому же адресу что и `f`, поэтому после выполнения функции в `f` хранится тоже `5`

Память во втором случае:
```
f - 00000001 - 5
n - 00000001 - 5
```
Для примитивов нужно не забывать использовать звезду (`*`), для массивов чуть проще, достаточно указать только в переменных функции, т.к. массив по сути указатель на первый элемент.

```
#include <stdio.h>

void pointer_example(int *n) {
    n[1] = 55;
    printf("2. %d\n", n[1]); // Смотрим значение внутри функции
}

int main() {
    int f[] = {4, 66};
    
    printf("1. %d\n", f[1]); // Смотрим ее значение до передачи в функцию
    pointer_example(&f);
    printf("3. %d\n", f[1]); // Смотрим ее значение после передачи в функцию

    return 0;
}
```

Результат:
```
1. 66
2. 55
3. 55
```

### 13. Sizeof

`sizeof` это оператор для определения используемой памяти переменных в битах. Это нужно просто запомнить:
```c
#include <stdio.h>

int main() {
    int a0 = 5;
    printf("a0:      %d\n", sizeof(a0));     // размер переменной a0, равно 4 потому что тип int
    printf("int:     %d\n", sizeof(int));    // размер типа int - он всегда равен 4
    double b0 = 44.4;
    printf("b0:      %d\n", sizeof(b0));     
    printf("double:  %d\n", sizeof(double)); // размер типа int - он всегда равен 8

    int m[] = {1, 2, 3, 4};
    printf("m:       %d\n", sizeof(m));      // размер массива, размер массива всегда учитывает размер типа данных, т.е. если одна переменная типа int  весит 4 бита, то один элемент массива типа int будет весит 4 бита, 2 элемента 8 и т.д.
    printf("size m:  %d\n", sizeof(m) / sizeof(int)); // количество элементов массива 
    double n[] = {1.1, 2.2, 3.3, 4.4};
    printf("n:       %d\n", sizeof(n));   // размер массива n  
    printf("size n:  %d\n", sizeof(n) / sizeof(double)); // количество элементов массива n
    printf("size n:  %d\n", sizeof(n) / sizeof(n[0])); // более универсальная запись, т.к. делим на размер первого элемента, т.е. данный способ будет работать с любым типом данных
    
    return 0;
}
```
Результат:
```
a0:      4
int:     4
b0:      8
double:  8
m:       16
size m:  4
n:       32
size n:  4
size n:  4
```











